
//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace Hathora.Utils
{
    using System;
    using System.Linq;
    using System.Collections.Generic;
    using System.Text.RegularExpressions;
    using Newtonsoft.Json;
  
    // This is required for the extension to use await with async web requests
    using UnityEngine;
    using System.Threading.Tasks;
    using System.Runtime.CompilerServices;

    // This is required for the extension to use await with async web requests
    using UnityEngine;
    using System.Threading.Tasks;
    using System.Runtime.CompilerServices;

    public class Utilities
    {
        public static bool IsDictionary(object obj) =>
            obj != null && obj.GetType().GetInterface(typeof(IDictionary<,>).Name) != null;

        public static bool IsList(object obj) =>
            (!Utilities.IsDictionary(obj) && !Utilities.IsString(obj) && obj.GetType().GetInterface(typeof(IEnumerable<>).Name) != null);

        // TODO: code review polyfilled for IsAssignableTo
        public static bool IsSameOrSubclass(Type potentialBase, Type potentialDescendant)
        {
            return potentialDescendant.IsSubclassOf(potentialBase) || potentialDescendant == potentialBase;
        }

        public static bool IsString(object obj)
        {
            if (obj != null)
            {
                var type = obj.GetType();
                return IsSameOrSubclass(type, typeof(string));
            }
            else
            {
                return false;
            }
        }
        // end of TODO

        public static bool IsPrimitive(object obj) =>
            obj != null && obj.GetType().IsPrimitive;

        public static bool IsEnum(object obj) =>
            obj != null && obj.GetType().IsEnum;

        ///<summary>
        /// Check if the object is a 'date time' or 'date only' object.
        ///</summary>
        public static bool IsDate(object obj) =>
            obj != null && (obj.GetType() == typeof(DateTime) || obj.GetType() == typeof(DateOnly));

        private static string StripSurroundingQuotes(string input)
        {
            Regex surroundingQuotesRegex = new Regex("^\"(.*)\"$");
            var match = surroundingQuotesRegex.Match(input);
            // TODO: code review, this was modified due to compiler error with the use of values
            if(match.Groups.Count() == 2)
            {
                return match.Groups.Last().ToString();
            }
            return input;
        }

        public static string ToString(object obj)
        {
            if(obj == null)
            {
                return null;
            }

            if(IsString(obj))
            {
                return obj.ToString();
            }

            if(IsPrimitive(obj))
            {
                return JsonConvert.SerializeObject(obj);
            }

            if(IsEnum(obj))
            {
                var attributes = obj.GetType().GetMember(obj.ToString()).First().CustomAttributes;
                if(attributes.Count() == 0)
                {
                    return JsonConvert.SerializeObject(obj);
                }

                var args = attributes.First().ConstructorArguments;
                if(args.Count() == 0)
                {
                    return JsonConvert.SerializeObject(obj);
                }
                return StripSurroundingQuotes(args.First().ToString());
            }

            if(IsDate(obj))
            {
                return StripSurroundingQuotes(JsonConvert.SerializeObject(obj, new JsonSerializerSettings(){ NullValueHandling = NullValueHandling.Ignore, Converters = new JsonConverter[] { new IsoDateTimeSerializer(), new EnumSerializer() }}));
            }
            return JsonConvert.SerializeObject(obj, new JsonSerializerSettings(){ NullValueHandling = NullValueHandling.Ignore, Converters = new JsonConverter[] { new IsoDateTimeSerializer(), new EnumSerializer() }});
        }

        public static bool IsContentTypeMatch(string expected, string actual)
        {
            if(expected == actual || expected == "*" || expected == "*/*")
            {
                return true;
            }

            var expectedSubs = expected.Split('/');
            var actualSubs = actual.Split('/');

            var expectedMediaType = expectedSubs[0];
            var expectedEncoding = expectedSubs[1];
            var actualMediaType = actualSubs[0];
            var actualEncoding = actualSubs[1];

            if(expectedMediaType == "*" && expectedEncoding == actualEncoding)
            {
                return true;
            }

            if(expectedMediaType != actualMediaType)
            {
                return false;
            }

            if(expectedEncoding == "*" || expectedEncoding == actualEncoding)
            {
                return true;
            }
            return false;
        }

        public static string PrefixBearer(string authHeaderValue)
        {
            if(authHeaderValue.StartsWith("bearer ", StringComparison.InvariantCultureIgnoreCase))
            {
                return authHeaderValue;
            }

            return $"Bearer {authHeaderValue}";
        }
    }

    public static class ExtensionMethods
    {
        ///<summmary>
        /// This extension to allow using await with async web requests
        ///</summmary>
        public static TaskAwaiter GetAwaiter(this AsyncOperation asyncOp)
        {
            var tcs = new TaskCompletionSource<object>();
            asyncOp.completed += obj => { tcs.SetResult(null); };
            return ((Task)tcs.Task).GetAwaiter();
        }
    }
    
}